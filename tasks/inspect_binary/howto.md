Using some tools that are usually distributed with Linux distros, we can
inspect the binaries generated by our assembly code (and other binaries too).

## hexdump

The first tool we are going to use is `hexdump`. If you are in the root
directory and have assembled and linked our `first.asm` program, then type:

    $ hexdump bin/first
    0000000 457f 464c 0102 0001 0000 0000 0000 0000
    0000010 0002 003e 0001 0000 0080 0040 0000 0000
    0000020 0040 0000 0000 0000 0190 0000 0000 0000
    0000030 0000 0000 0040 0038 0001 0040 0005 0004
    0000040 0001 0000 0005 0000 0000 0000 0000 0000
    0000050 0000 0040 0000 0000 0000 0040 0000 0000
    0000060 008c 0000 0000 0000 008c 0000 0000 0000
    0000070 0000 0020 0000 0000 0000 0000 0000 0000
    0000080 3cb8 0000 bf00 0000 0000 050f 0000 0000
    0000090 0000 0000 0000 0000 0000 0000 0000 0000
    00000a0 0000 0000 0000 0000 0000 0000 0003 0001

(I truncated part of the output because it was too large.)

What we see here is the contents of our binary executable file, in hexadecimal
format. The first number in each line is just the offset of that line
with respect to the beginning of the file. Then each character after that
represents 16 bits or 2 bytes. Each group of 4 characters is then a group of
8 bytes.

In this way, we can see the exact output that `nasm` and `ld` generated for
our assembly code. You will also notice that certain combinations of
instruction/operand will always generate the same output.

## objdump

We can also "disassemble" our binary, which means to generate the assembly code
from the binary. To do this, type:

    $ objdump -D bin/first
    
    bin/first:     file format elf64-x86-64
    
    
    Disassembly of section .text:
    
    0000000000400080 <_start>:
      400080:	b8 3c 00 00 00       	mov    $0x3c,%eax
      400085:	bf 00 00 00 00       	mov    $0x0,%edi
      40008a:	0f 05                	syscall

We can see some interesting things here. First, our `mov rax, 60` command
from `first.asm` was translated to `b8 3c 00 00 00`. But more importantly,
through the disassembly we learn that this is the code for `mov $0x3c,%eax`,
which, in the syntax that we are writing (called "Intel" syntax) would be
`mov eax, 60`. Recall from [earlier](../registers/theory.md) that **EAX** is
just the lower 32-bit portion of **RAX**.
